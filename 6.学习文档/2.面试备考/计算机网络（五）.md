# 计算机网络（五）

## 1.time_wait是如何引起的，有什么作用，有什么弊端如何解决

* 如何引起

  首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值为数据包在网络中的最大生存时间。TCP在连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。

* 有什么用

  **1）为使旧的数据包在网络因过期而消失**

  **2）为实现TCP全双工连接的可靠释放**

* 弊端

  在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。

  还有一种情况，假设假设假设，今天双十一，这是一台Tmall的服务器，因为一些原因，服务器进程挂掉了，退出了，由于是服务器主动关闭连接，因此会有TIME_WAIT状态存在，也就意味着服务器进程想立即重启，但是起不来，因为端口（可能是80）还被之前处于TIME_WAIT的连接占用着，如果TIME_WAIT状态维持60秒，60秒服务器都起不来，双十一，啧啧。

* 如何解决

  1）首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。

  （2）由于time_wait状态是在主动关闭的一方出现的，所以在设计协议逻辑的时候，尽量由客户端主动关闭，避免服务端出现time_wait

## 2.使用c语言编写网络程序，假设再调用listen函数时，第二个参数是20，这个20有什么真实含义？

> 在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。

第二个参数backlog代表的是相应的socket可以排队的最大连接数。

由于客户端client 发起connect(）连接时。需要建立TCP三次握手连接需要时间，所有会有一个队列来存储客户端对服务器发起的connect连接。

当客户端完成连接后。连接被放到端口的socket的队列里面，等待服务器去响应。
当服务器调用accept()来获取队列中的连接，这时候就会从队列中移除。
listen()函数的第二个参数就是去设置这个队列的大小的。

## 3.当tcp的一段关闭了连接，另一端可以感知到吗？

 在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。系统默认是设置的2小时的心跳频率。

心跳检测步骤：
1 客户端每隔一个时间间隔发生一个探测包给服务器
2 客户端发包时启动一个超时定时器
3 服务器端接收到检测包，应该回应一个包
4 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
5 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了