# 1.语言基础总结

## 一、3月10日

* 1.c和c++中struct的区别是什么？以及关于c++中为什么保留struct关键字？

  * c++语言中struct中可以定义函数，c不可以
  * c++语言中struct有丰富的权限关系，包括public，private，protect
  * c++语言中的struct有丰富的继承关系，c没有

  * c语言中struct是用户自定义数据类型，没有权限设置，启程原变量只能是一些变量的集合体，不能隐藏数据，且成员变量不能为函数。
  * c++中struct是一种抽象数据类型，他支持权限设置，支持成员函数，变量默认权限为private，成员函数默认权限为public，在使用模板类是只能写template<class Type> 或template<typename Type>而不能写template<struct Type>
  * c++中保留struct的目的是由于c++是向下兼容c语言的，出于对c语言编程者编程习惯的照顾，保留了strruct关键字。也是为了与c语言兼容。

* C++11中const与constexpr的区别？

  * const和constexpr都可以来修饰对象和函数。
  * const并不限定是编译期常量还是运行期常量，而constexpr必须是编译期常量（在编译阶段得到结果）
  * 修饰对象的时候两者之间最基本的区别是：
    * const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。
    * constexpr是修饰一个常量表达式。但constexpr不是修饰常量表达式的唯一途径。

  * 修饰函数的时候两者之间最基本的区别是：

    * const只能用于非静态成员的函数而不是所有函数。//它保证成员函数不修改任何非静态数据。
    * constexpr可以用于含参和无参函数。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数： 1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素 (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了) 2.参数和返回值必须是字面值类型

  * 常量表达式

    常量表达式的概念如下

    必须是可以在编译阶段被识别的。比如模版的参数／数组的大小。

    用constexpr修饰某物并不保证它一定在编译时被计算，也可以在运行时被计算

  

* 请尽可能多的说出你所知道的关于c++中虚函数的相关知识？

“多态（英语：polymorphism），是指计算机程序运行时，相同的消息可能会送给多个不同的类别对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。”其实更简单地来说，就是“在用父类指针调用函数时，实际调用的是指针指向的实际类型（子类）的成员函数”。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。而虚函数则是加了virtual修饰词的类的成员函数。

在具体的使用过程中**当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定**”。那么，虚函数又是怎么实现的呢？

对于一个类对象，其中成员函数放在代码区，为该类的所有对象公有，即不管新建多少个该类的对象，所对应的都是同一个函数存储区的函数。而成员变量则为各个对象所私有，即每新建一个对象都会新建一块内存区（堆区）用来存储var值。在调用成员函数时，程序会根据类的类型，找到对应代码区所对应的函数并进行调用。调用普通函数时，程序根据指针的类型到类所对应的代码区找到所对应的函数，所以当使用继承自同一父类的子类对象用父类指针调用成员函数时，都调用了父类指针代码区指向的父类的成员函数，即指针的类型决定了普通函数的调用。

这时如果sizeof一个类D的对象，会发现比类C的对象大4个字节。多出来的这4个字节就是实现虚函数的关键----虚函数表指针vptr。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数具体实现所对应的位置（全局数据区）。注意，普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，sizeof的值也只包括vptr和var所占内存的大小（也是个常出现的问题），并且vptr通常会在对象内存的最起始位置。另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr，而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。在重复一遍虚函数实现的过程：**通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。**如开头例子中，当调用vir_func函数时，分别通过Base、a、b指针找到对应的vptr，然后找到各自的vtbl，最后通过vtbl找到各自虚函数的具体实现。所以虚函数的调用时由指针所指向内存块的具体类型决定的。

以上就是虚函数的实现方式。对于虚函数还有个实际使用和面试经常会出现的问题：**构造函数和析构函数可以是虚函数吗**？答案是**构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数**。下面我们来看看为什么。首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。那么为什么析构函数推荐最好设置为虚函数呢？如文章开头的例子中，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员也进行析构啦。

对于构造函数和析构函数与虚函数的关系我们也可以从另一方面来理解。通常是如例子中base *a=new(A)这样创建一个对象时调用构造函数，此时我们是在new函数中直接指定类名字的，当然会直接调用对应类的构造函数，不会出现基类类型实际指向子类的情况出现。而调用析构函数通常是针对对象的操作，如delete(a)，此时我们当然希望可以调用到a实际指向的类型（类A）的析构函数，故需要设置为虚函数。