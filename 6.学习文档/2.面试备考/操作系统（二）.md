# 操作系统（二）

## 1.请你对用户态，内核态以及系统调用三个概念做出解释

#### 为什么要有用户态和内核态？

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

* 用户态：当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。

* 内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。

* 系统调用：

  在计算机中，系统调用又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。

## 2.线程同步是干什么的，线程同步有哪些机制？

>  **线程同步是什么？**当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态

* 线程同步是干什么的？

  **线程同步是为了防止多个线程同时访问同一个数据对象时，对数据造成破坏。**

  **线程的同步是保证多线程安全访问资源的一种手段。**

* #### 四种进程或线程同步互斥的控制方法:

  1、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 

  2、互斥量：为协调共同对一个共享资源的单独访问而设计的。 

  3、信号量：为控制一个具有有限数量用户资源而设计。 

  4、事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。

  #### 1、临界区

  通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。

  总结下关键段：

  1）关键段共有初始化、销毁、进入和离开关键区域四个函数。

  2）关键段可以解决线程的互斥问题，但因为具有“线程所有权”，所以无法解决同步问题。

  3）推荐关键段与旋转锁配合使用。

  #### 2、互斥对象

  互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。

  总结下互斥量Mutex：

  1）互斥量是内核对象，它与关键段都有“线程所有权”所以不能用于线程的同步。

  2）互斥量能够用于多个进程之间线程互斥问题，并且能解决某进程意外终止所造成的“遗弃”问题。 

  #### 3、信号量

  信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

  在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。

  #### 4、事件对象

  通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作

  总结下事件Event

  1）事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。

  2）事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。
  
  3）事件可以解决线程间同步问题，因此也能解决互斥问题。 

## 3.内核线程和用户线程有什么区别？

- **用户级线程：**是指不需要内核支持而在用户程序中实现的线程，它的内核的切换是由用户态程序自己控制内核的切换，不需要内核的干涉。但是它不能像内核级线程一样更好的运用多核CPU。

  优点：

  （1） 线程的调度不需要内核直接参与，控制简单。

  （2） 可以在不支持线程的操作系统中实现。

  （3） 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起，可以节约更多的系统资源。

  缺点：

  （1） 一个用户级线程的阻塞将会引起整个进程的阻塞。

  （2） 用户级线程不能利用系统的多重处理，仅有一个用户级线程可以被执行。

* **内核级线程:**切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态。可以很好的运用多核CPU，就像Windows电脑的四核八线程，双核四线程一样。

  优点：

  （1）当有多个处理机时，一个进程的多个线程可以同时执行。

  （2） 由于内核级线程只有很小的数据结构和堆栈，切换速度快，当然它本身也可以用多线程技术实现，提高系统的运行速率。

  缺点：

  （1） 线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源。（就是必须要受到内核的监控）

- ### 用户级线程和内核级线程的区别：

  它们之间的差别在于性能。

  1. 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。
  2. 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。
  3. 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。
  4. 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。
  5. 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。