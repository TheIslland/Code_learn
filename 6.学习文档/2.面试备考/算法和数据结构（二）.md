# 算法和数据结构（二）

## 1.如果现在由K个有序数组，如何合并成一个有序数组

* 申请内存，放入数组后堆排序，根据已有数组构建堆需要O(n)的时间复杂度，每次删除堆顶元素需要O(logn)的时间复杂度，所以总的时间开销为，O(n+nlogn)，平均时间复杂度为O(nlogn)
*  有没有别的算法呢？我先来说一说败者树（loser tree）。也许有些人对loser tree不是很了解，其实它是一个比较经典的外部排序方法，也就是有x个已经排序好的文件，将其归并为一个有序序列。败者树的思想咋一看有些绕，其实是为了减小比较次数。首先简单介绍一下败者树：败者树的叶子节点是数据节点，然后两两分组（如果节点总数不是2的幂，可以用类似完全树的结构构成树），内部节点用来记录左右子树的优胜者中的“败者”（注意记录的是输的那一方），而优胜者则往上传递继续比较，一直到根节点。如果我们的优胜者是两个数中较小的数，则根节点记录的是最后一次比较中的“败者”，也就是所有叶子节点中第二小的那个数，而最小的那个数记录在一个独立的变量中。这里要注意，内部节点不但要记录败者的数值，还要记录对应的叶子节点。如果是用链表构成的树，则内部节点需要有指针指向叶子节点。这里可以有一个trick，就是内部节点只记录“败者”对应的叶子节点，具体的数值可以在需要的时候间接访问（这一方法在用数组来实现败者树时十分有用，后面我会讲到）。关键的来了，当把最小值输出后，最小值所对应的叶子节点需要变成一个新的数（或者改为无穷大，在文件归并的时候表示文件已读完）。接下来维护败者树，从更新的叶子节点网上，依次与内部节点比较，将“败者”更新，胜者往上继续比较。由于更新节点占用的是之前的最小值的叶子节点，它往上一直到根节点的路径与之前的最小值的路径是完全相同的。内部节点记录的“败者”虽然称为“败者”，但却是其所在子树中最小的数。也就是说，只要与“败者”比较得到的胜者，就是该子树中最小的那个数（这里讲得有点绕了，看不明白的还是找本书看吧，对照着图比较容易理解）。
  注：也可以直接对N构建败者树，但是败者树用数组实现时不能像堆一样进行增量维护，当叶子节点的个数变动时需要完全重新构建整棵树。为了方便比较堆和败者树的性能，后面的分析都是对n个数构建的堆和败者树来分析的。
*   败者树在维护的时候，比较次数是logn+1,  败者树从下往上维护，每上一层，只需要和父节点比较一次，而堆是自上往下维护，每一层需要和左右子节点都比较，需要比较两次，从这个角度，败者树比堆更优一点，但是，败者树每一次维护，必然是从叶子节点到根节点的一条路径，而堆维护的时候有可能在中间某个层次停止，这样败者树虽然每层比堆比较的次数少，但是堆比较的层数可能比较少。
* O（Nlogn）

## 2.请具体说明，为什么归并排序适合处理大数据排序情况

* 首先归并排序采取了，分治的思想，即把一个足够大的问题，分成若干个便于解决的小问题，先解决小问题，再通过小问题的结果解决大问题。
* 这正好便于由大数据所造成的不便，即当前计算机内存无法直接讲大数据直接读取近内存中排序，我们先采取讲大数据划分为若干个小数据，将小数据排为基本有序后，再采用堆排序或者败者树的方法讲其合并为有序数组放在文件中。

## 3.如何快速的输出无序数组前k大的值，请说明你的方法，并分析时间复杂度

首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)

分别用堆和败者树来实现

       堆实现： 维护一个大小为k的小顶堆，每来一个数都和堆顶进行比较，如果比堆顶小，直接舍弃，否则替换堆顶，维护堆，直到n个数都处理完毕，时间复杂度为O(nlogk)

 


       败者树实现：当用数组来实现败者树时， 维护一个叶子节点个数为k的败者树，注意是叶子节点个数而不是所有节点个数，数字较小者取胜，则最顶层保存的是值最小的叶子节点，每来一个数和最小值比较，如果比最小值还小，直接舍弃，否则替换最小值的节点值，从下往上维护败者树，最后的k个叶子节点中保存的就是所有数中值最大的k的，时间复杂度为O(nlogk)


​     

首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数

利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。



当有相同元素的时候，

首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)